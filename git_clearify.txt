// TODO

$git clone <url> <local_dir>

==========================================================================================================

// TODO
$git init
$git remote add <remote-shortname> <url>
$git commit


** comparison:
* clone cannot change remote_shortname?

==========================================================================================================

**
Difference between git and svn

svn: central repository to working copy interaction
ex.
  checking working copy into SVN's central repository

git: repository to repository interaction (no distinction between working copy and central repository)
ex.
  push or pull commits from one repository to another, can give any repository special meaning (such as central or origin accomplished through convention rather then hardwired like the svn)


==========================================================================================================

Staging:

**"git add" STAGES what will go into the next commit, ex. if a group of change  were part of change_A, another group of changes were part of change_B, they can be added seperatedly, result them to be in different commit

** instead of commiting all the changes made since last commit, stage allow user to group related changes into highly focused snapshots before actually committing to the project history.

** git doesn't differentiate between staging changes in new files vs. changes in files that have already been added to the repository


==========================================================================================================

Commit:

** git commit is different from svn commit. Staged snapshots are committed to the local repository as a "safe" version, and it requires no interaction with other git repositories (plainly local). Whereas the svn commit merges the local working directory with the central.

** git commits are always a snapshot commited to the local repository, SVN is a working copy commited to a central repository. In a way, git isn't forced to interact with the central repository until the user is ready, each developer's local repository is a buffer between their contributions and the central repository.

** SVN tracks difference of files between working copy and contral. Git
version control model is based on snapshots. Git records the entire contents
of each file in every commit. Making Git operation faster than SVN, since svn
uses a compare.

==========================================================================================================

Checkout:

** read only operation. The "current state" remain untouched in the master branch, while the HEAD (instead of pointing to master or some working branch), points directly to a previous commit. Called a "detached HEAD".

** To resume developing, one need to first get back to the "current state" of the project (whether it the master or other branches).

ex. 
  $git log --oneline
b7119f2 Continue doing crazy things
872fa7e Try something crazy
a1e8fb5 Make some important changes to hello.py
435b61d Create hello.py
9773e52 Initial import

  $git checkout a1e8fb5
# Nothing done here will be saved in the repository

  $git checkout master
# Go back to the current state, can use "$git revert" or "git reset" to undo undesired changes.

** the whole idea of version control system (VCS) is to store "safe" copies of a project. Once the history is built, "$git checkout" is to used to "load" any of the snapshots onto the development machine.


==========================================================================================================


Reverting vs. Resetting

** Revert advantages over Resetting: 
  1. revert doesn't change project history, making it "safer" for commits that have already been published to a shared repository.
  2. revert can target an individual commit at an arbitary point in the commit history; whereas, "$git reset" can only work backward from the current commit.

** if an older commit in the history is desired, one would have to remove all of the commits that occured after the target commit, remove it, then re-commit all of the subsequent commits.

** if "$git revert" is a "safe" way to undo changes, one can think "$git
reset" as the dangerous method. When undo with reset, there is no way to
retrieve the original copy--it's a permanant undo. 

** The ONLY GIT COMMANDS THAT HAS POTENTIAL TO LOSE WORKS. Extra care must be taken. RECOMMENDED TO USE ON LOCAL CHANGES ONLY, should not reset snapshots that have been shared with other developers.

** "$git reset" is a way to clean up a repository by unstaging changes or uncommitting a series of snapshots, the "--hard" flag comes in handy when the working directory has gone horribly wrong and one need a clean slate to work with.

** Whereas "reverting" is designed to safely undo a public commit, "reseting"
is designed to undo local changes. Because of the distinct goals, two commands
were implemented differently:
  resetting: complitely removes a changeset. After publishing a commit, one have to assume that other developers are reliant upon it, and shouldn't reset on it.
  reverting: maintains the original changeset and uses a new commit to apply the undo.
